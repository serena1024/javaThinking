15.2 简单泛型
	为了创造容器类从而引出了泛型的概念。容器就是存放使用对象的地方。
	泛型的只要目的之一就是用来指定容器要持有什么类型的对象，由编译器来保证类型的准确性。因此与其使用Object，我们更喜欢暂时不指定类型
	而是稍后再决定使用什么类型。要达到这个目的就需要使用类型参数，用尖括号括住，放在类名的后面。然后在使用这个类的时候再用实际的
	类型替换此类型参数。
15.2.1 一个元组类库
	元组（tuple），将一组对象直接打包存储于其中一个单一的对象，这个容器对象允许读取其中元素，但是不允许向其中存放新的对象。这个概念也叫做数据传送对象
	或者信使。通常元组可以有任意长度，元组中的对象可以是任意不同的类型。
15.3 泛型接口
	泛型也可以用于接口，例如生成器（generator），这是一种专门负责生成对象的类。实际上这是工厂方法设计模式的一种应用。
15.8
工厂模式的作用 ：
	首先，工厂模式是为了解耦：把对象的创建和使用的过程分开。就是Class A 想调用 Class B ，那么A只是调用B的方法，而至于B的实例化，就交给工厂类。
	其次，工厂模式可以降低代码重复。如果创建对象B的过程都很复杂，需要一定的代码量，而且很多地方都要用到，那么就会有很多的重复代码。
	我们可以这些创建对象B的代码放到工厂里统一管理。既减少了重复代码，也方便以后对B的创建过程的修改维护。
	（当然，我个人觉得也可以把这些创建过程的代码放到类的构造函数里，同样可以降低重复率，而且构造函数本身的作用也是初始化对象。
	不过，这样也会导致构造函数过于复杂，做的事太多，不符合java 的设计原则。）
	由于创建过程都由工厂统一管理，所以发生业务逻辑变化，不需要找到所有需要创建B的地方去逐个修正，只需要在工厂里修改即可，降低维护成本。
	同理，想把所有调用B的地方改成B的子类B1，只需要在对应生产B的工厂中或者工厂的方法中修改其生产的对象为B1即可，
	而不需要找到所有的new B（）改为new B1()。
	另外，因为工厂管理了对象的创建逻辑，使用者并不需要知道具体的创建过程，只管使用即可，减少了使用者因为创建逻辑导致的错误。
15.10 通配符 ？
15.10.2 逆变，超类通配符
    <? super MyClass> 不能声明<T super MyClass>
15.11 问题
    泛型中，任何基本类型都不能作为类型参数

14.1 为什么要用RTTI
14.2 Class对象
	要理解RTTI在Java中的工作原理，首先必须要知道类型信息在运行时是如何表示的。这项工作是由成为Class对象的特殊对象完成的。
 它包含了与类有关的信息。
 	类是程序的一部分，每个类都有一个Class对象。换言之，每当编写并且编译了一个新类，就会产生一个class对象。为了生成这个类
 的对象，运行这个程序的Java虚拟机将使用被称为“类加载器”的子系统。
 	所有的类就是在第一次使用的时候，动态加载到jvm中的。当程序创建第一个对类的静态成员引用的时候，就会加载这个类。构造器也是类的静态方法。
  因此，使用new的时候也会被当作对类的静态成员的引用。
  	因此，Java程序在它开始运行之前并非被完全加载，各个部分是在必需才加载的。
  	类加载器首先检查这个类的Class对象是否已加载。如果尚未加载，默认的类加载器就会根据类名查找.class文件。
  	如果你有个Class对象，还可以使用getSuperclass()方法查询其直接基类。
  	Class的newInstance()方法是实现“虚拟构造器”的一种途径，另外，使用newInstance()来创建的类，必须由默认的构造器。
 14.2.1 类字面常量 类似于 FancyToy.class这样做不仅更简单而且更安全，因为它在编译的时候就会受到检查，因此不需要在try语块中
  并且它根除了对forName()方法的调用，所以更高效。
  	类字面常量不仅可以用于普通类，也可以用于接口.数组/以及基本数据类型。另外对于基本数据类型的包装器类，还有一个标准字段TYPE。
  TYPE字段是一个引用，指向对应的基本数据类型的Class对象。建议使用.class的形式，和普通了保持一致性。
  	注意：当使用.class来创建对Class对象的引用时，不会自动的初始化该Class对象，为了使用类而做的准备工作实际上包含三个步骤。
  	1.加载，这是由类加载器执行的。该步骤将查找字节码，并从这些字节码中创建一个Class对象。
  	2.链接，在链接阶段将验证类中的字节码，为静态域分配存储空间，如果必须的话，将解析这个类创建的对其他类的所有引用。
  	3.初始化，如果该类具有超类，则对其初始化，执行静态初始化器和静态初始化块。
  	初始化被延迟到了对静态方法或者非静态域进行首次引用时才执行。
 14.2.2 泛化的Class引用
 	Class引用总是指向某个Class对象，它可以制造类的实例，并包含可作用于这些实例的所有方法。它还包含该类的静态成员，因此，Class的引用
 	表示的就时它所指向对象的确切类型，而该对象就是Class类的一个对象。
 	在JavaSE5中，Class<?>优于平凡的Class，即便它时等价的，且平凡的Class不会产生编译器警告信息。Class<?>的好处就是它表示使用了一个
 	非具体的类引用。
 	为了创建一个Class引用，它被限定为某种类型，或该类型的任何子类型，你需要将通配符与extends关键字结合，创建一个范围，。
 14.2.3 新的转型语法
 	cast()方法接受参数对象，并将其转型为Class引用的类型。
 14.3 类型转换前先做检查
 	迄今为止我们知道的RTTI形式包括。
 	1.传统的类型转换，如果执行了一个错误的类型转换会抛出一个ClassCastException
 	2.代表对象类型的Class对象。通过查询Class对象可以获取运行时所需的信息。
 	3.关键字instanceof.它返回的是一个布尔值，告诉我们对象是不是某个特定类型的实例。
 14.3.3 递归计数
  isAssignableFrom()方法是判断是否为某个类的父类
  instanceof() 判断是否是某个类的实例
 14.4 注册工厂
  使用工厂设计模式，将对象的创建工作交给类本身去执行。工厂方法可以被多态地调用，从而为你创建恰当类型的对象。
 14.5 instanceof与Class的等价性
 14.6 反射，运行时的类信息
 	Class类和java.lang.reflect类库一起支持了反射的概念，该类库包含了Field/Method 以及Constructor类（每个类都实现老林Member接口）。
 	这些类型的对象是在JVM运行时创建的，用以表示未知类里对应的成员。这样你就可以用Constructor创建新的对象，用get和set方法读取和修改Field对象
 	关联的字段。用invoke()调用与Method对象关联的方法。另外还可以调用getFields(),getMethods(),getConstructors()等遍历方法，
 	以返回表示字段，方法以及构造器的对象的数组。这样，匿名的对象信息就能在运行时被完全确定下来，而在编译时不需要做任何事情。
 	RTTI和反射的真正区别是，RTTI在编译的时候就打开和检查.class文件，而对于反射机制来说，.class文件在编译的时候是不可取的，所以是在运行时打开
 	和检查文件。
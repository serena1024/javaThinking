14.1 为什么要用RTTI
14.2 Class对象
	要理解RTTI在Java中的工作原理，首先必须要知道类型信息在运行时是如何表示的。这项工作是由成为Class对象的特殊对象完成的。
 它包含了与类有关的信息。
 	类是程序的一部分，每个类都有一个Class对象。换言之，每当编写并且编译了一个新类，就会产生一个class对象。为了生成这个类
 的对象，运行这个程序的Java虚拟机将使用被称为“类加载器”的子系统。
 	所有的类就是在第一次使用的时候，动态加载到jvm中的。当程序创建第一个对类的静态成员引用的时候，就会加载这个类。构造器也是类的静态方法。
  因此，使用new的时候也会被当作对类的静态成员的引用。
  	因此，Java程序在它开始运行之前并非被完全加载，各个部分是在必需才加载的。
  	类加载器首先检查这个类的Class对象是否已加载。如果尚未加载，默认的类加载器就会根据类名查找.class文件。
  	如果你有个Class对象，还可以使用getSuperclass()方法查询其直接基类。
  	Class的newInstance()方法是实现“虚拟构造器”的一种途径，另外，使用newInstance()来创建的类，必须由默认的构造器。
 14.2.1 类字面常量 类似于 FancyToy.class这样做不仅更简单而且更安全，因为它在编译的时候就会受到检查，因此不需要在try语块中
  并且它根除了对forName()方法的调用，所以更高效。
  	类字面常量不仅可以用于普通类，也可以用于接口.数组/以及基本数据类型。另外对于基本数据类型的包装器类，还有一个标准字段TYPE。
  TYPE字段是一个引用，指向对应的基本数据类型的Class对象。建议使用.class的形式，和普通了保持一致性。
  	注意：当使用.class来创建对Class对象的引用时，不会自动的初始化该Class对象，为了使用类而做的准备工作实际上包含三个步骤。
  	1.加载，这是由类加载器执行的。该步骤将查找字节码，并从这些字节码中创建一个Class对象。
  	2.链接，在链接阶段将验证类中的字节码，为静态域分配存储空间，如果必须的话，将解析这个类创建的对其他类的所有引用。
  	3.初始化，如果该类具有超类，则对其初始化，执行静态初始化器和静态初始化块。
  	初始化被延迟到了对静态方法或者非静态域进行首次引用时才执行。